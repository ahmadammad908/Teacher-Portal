
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hand Particle Controller</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        
        /* UI Overlay */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.8); z-index: 10;
        }
        
        button {
            padding: 15px 40px; font-size: 20px; font-weight: bold; cursor: pointer;
            background: #00ff88; border: none; border-radius: 50px; color: #000;
            box-shadow: 0 0 20px rgba(0,255,136, 0.5); transition: 0.3s;
        }
        button:hover { transform: scale(1.1); background: #fff; }
        
        #status { color: white; margin-top: 20px; font-size: 18px; }
        
        #video-preview {
            position: absolute; bottom: 10px; right: 10px; width: 160px; height: 120px;
            transform: scaleX(-1); border: 2px solid #333; border-radius: 10px; z-index: 5; opacity: 0.8;
        }

        #instructions {
            position: absolute; top: 20px; left: 20px; color: rgba(255,255,255,0.6); 
            z-index: 5; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="overlay">
        <button id="start-btn">ALLOW CAMERA & START</button>
        <div id="status">Click button to enable permissions</div>
    </div>

    
    <video id="video-input" playsinline style="display:none"></video>
    <video id="video-preview" playsinline muted autoplay></video>
    
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Variables ---
        const PARTICLE_COUNT = 5000;
        let particles, geometry, material;
        let isRunning = false;
        
        const state = {
            targetX: 0, targetY: 0, spread: 1.0, hue: 0.0, isPinching: false
        };

        const overlay = document.getElementById('overlay');
        const statusText = document.getElementById('status');
        const startBtn = document.getElementById('start-btn');
        const videoInput = document.getElementById('video-input');
        const videoPreview = document.getElementById('video-preview');

        // --- 1. Three.js Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 100;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create Particles
        function initParticles() {
            geometry = new THREE.BufferGeometry();
            const pos = [], col = [], orig = [];
            const color = new THREE.Color();

            for(let i=0; i<PARTICLE_COUNT; i++){
                const x = (Math.random()-0.5)*100;
                const y = (Math.random()-0.5)*100;
                const z = (Math.random()-0.5)*100;
                pos.push(x,y,z);
                orig.push(x,y,z); // Original position for morphing
                
                color.setHSL(Math.random(), 0.7, 0.5);
                col.push(color.r, color.g, color.b);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(col, 3));
            geometry.setAttribute('original', new THREE.Float32BufferAttribute(orig, 3));

            material = new THREE.PointsMaterial({ size: 1.2, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }
        initParticles();

        // --- 2. Camera & AI Setup ---
        async function loadAI() {
            statusText.innerText = "Loading AI Models...";
            
            // Load Scripts dynamically
            await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js");
            await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js");
            
            statusText.innerText = "Starting Camera...";
            
            const hands = new window.Hands({locateFile: (file) => 
                `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6
            });
            
            hands.onResults(onResults);
            
            const cam = new window.Camera(videoInput, {
                onFrame: async () => { await hands.send({image: videoInput}); },
                width: 640, height: 480
            });
            
            await cam.start();
            
            // Hook up preview manually to ensure it works
            if (navigator.mediaDevices.getUserMedia) {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                videoPreview.srcObject = stream;
            }

            overlay.style.display = 'none'; // Hide menu when done
            isRunning = true;
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                
                // Track Position (Index finger base)
                // Invert X because camera is mirrored
                const x = (1 - lm[9].x) * 2 - 1; 
                const y = -(lm[9].y * 2 - 1);
                
                state.targetX = x * 80;
                state.targetY = y * 50;

                // Expansion (Thumb Tip to Pinky Tip)
                const spreadDist = Math.hypot(lm[4].x - lm[20].x, lm[4].y - lm[20].y);
                // Map distance to expansion factor
                state.spread = spreadDist * 5.0; // Multiplier for visual effect

                // Pinch (Color Change)
                const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                if (pinchDist < 0.05) {
                    if(!state.isPinching) {
                        state.isPinching = true;
                        state.hue += 0.1; // Shift color
                    }
                } else {
                    state.isPinching = false;
                }
            }
        }

        function loadScript(src) {
            return new Promise(resolve => {
                const s = document.createElement('script');
                s.src = src; s.onload = resolve; document.head.appendChild(s);
            });
        }

        // --- 3. Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            if(!isRunning) return;

            // Move entire cloud
            particles.position.x += (state.targetX - particles.position.x) * 0.1;
            particles.position.y += (state.targetY - particles.position.y) * 0.1;
            particles.rotation.y += 0.005;

            const pos = geometry.attributes.position.array;
            const orig = geometry.attributes.original.array;
            const col = geometry.attributes.color.array;
            const colorHelper = new THREE.Color();

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const ix = i*3, iy = i*3+1, iz = i*3+2;
                
                // Expand logic
                let tx = orig[ix] * (0.5 + state.spread);
                let ty = orig[iy] * (0.5 + state.spread);
                let tz = orig[iz] * (0.5 + state.spread);

                // Smoothly move vertex
                pos[ix] += (tx - pos[ix]) * 0.1;
                pos[iy] += (ty - pos[iy]) * 0.1;
                pos[iz] += (tz - pos[iz]) * 0.1;

                // Color logic
                colorHelper.setHSL((state.hue + i*0.0001)%1, 0.8, 0.5);
                col[ix] = colorHelper.r;
                col[iy] = colorHelper.g;
                col[iz] = colorHelper.b;
            }
            
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // Button Click Event
        startBtn.addEventListener('click', () => {
            startBtn.innerText = "Requesting Camera...";
            navigator.mediaDevices.getUserMedia({ video: true })
                .then(() => {
                    loadAI();
                    animate();
                })
                .catch(err => {
                    alert("Camera Permission Denied! Please allow camera access in browser URL bar.");
                    statusText.innerText = "Camera Denied. Refresh and Try Again.";
                });
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>








